# Design Document

## Overview

The playtest runner is a Go-based test execution system that simulates multiple WebSocket clients interacting with the Sushi Go backend server. It reads test scenarios from YAML files, executes them sequentially, and captures client state for validation and debugging. The system uses variable substitution to handle dynamic values like game IDs that are generated by the server.

## Architecture

The system consists of four main components:

1. **YAML Parser**: Reads and validates playtest definition files
2. **Client Simulator**: Manages WebSocket connections and message exchange
3. **Variable Store**: Stores and retrieves values from server responses
4. **Test Runner**: Orchestrates test execution and reports results

```
┌─────────────┐
│  YAML File  │
└──────┬──────┘
       │
       v
┌─────────────────┐
│  YAML Parser    │
└──────┬──────────┘
       │
       v
┌─────────────────┐      ┌──────────────────┐
│  Test Runner    │◄────►│ Variable Store   │
└──────┬──────────┘      └──────────────────┘
       │
       v
┌─────────────────┐      ┌──────────────────┐
│ Client Simulator│◄────►│ Backend Server   │
└─────────────────┘      └──────────────────┘
```

## Components and Interfaces

### YAML Parser

**Purpose**: Parse playtest YAML files into Go structs

**Interface**:
```go
type PlaytestDefinition struct {
    Turns []Turn `yaml:"turns"`
}

type Turn struct {
    Client  string                 `yaml:"client"`
    Message map[string]interface{} `yaml:"message"`
}

func ParsePlaytest(filepath string) (*PlaytestDefinition, error)
```

### Client Simulator

**Purpose**: Manage WebSocket connections for simulated clients

**Interface**:
```go
type ClientSimulator struct {
    ID         string
    conn       *websocket.Conn
    messages   []json.RawMessage
    gameState  map[string]interface{}
}

func NewClientSimulator(id string, serverURL string) (*ClientSimulator, error)
func (c *ClientSimulator) SendMessage(msg map[string]interface{}) error
func (c *ClientSimulator) ReceiveMessage() (json.RawMessage, error)
func (c *ClientSimulator) Close() error
```

### Variable Store

**Purpose**: Store and retrieve values from server responses

**Interface**:
```go
type VariableStore struct {
    vars map[string]interface{}
}

func NewVariableStore() *VariableStore
func (v *VariableStore) Set(key string, value interface{})
func (v *VariableStore) Get(key string) (interface{}, bool)
func (v *VariableStore) Substitute(template map[string]interface{}) map[string]interface{}
```

**Variable Substitution Rules**:
- Variables are referenced using angle brackets: `<variableName>`
- The system automatically stores `gameId` from responses as `globalGame`
- Empty strings in templates are sent as-is (not substituted)
- Substitution occurs recursively through nested maps

### Test Runner

**Purpose**: Execute playtest scenarios and report results

**Interface**:
```go
type TestRunner struct {
    clients map[string]*ClientSimulator
    store   *VariableStore
    serverURL string
}

func NewTestRunner(serverURL string) *TestRunner
func (r *TestRunner) RunPlaytest(filepath string) error
func (r *TestRunner) executeTurn(turn Turn) error
func (r *TestRunner) printResults()
```

## Data Models

### Playtest YAML Structure

```yaml
turns:
  - client: A                    # Client identifier
    message:
      type: join_game            # Message type
      gameId: ""                 # Empty = server generates
  - client: B
    message:
      type: join_game
      gameId: <globalGame>       # Variable reference
  - client: A
    message:
      type: start_game
      gameId: <globalGame>
  - client: A
    message:
      type: select_card
      cardIndex: 0
```

### Client State Structure

```go
type ClientState struct {
    ID           string
    Messages     []json.RawMessage
    CurrentGame  string
    GameState    map[string]interface{}
}
```

## Correctness Properties

*A property is a characteristic or behavior that should hold true across all valid executions of a system-essentially, a formal statement about what the system should do. Properties serve as the bridge between human-readable specifications and machine-verifiable correctness guarantees.*


### Property Reflection

After reviewing all identified properties, several can be consolidated:

- Properties 2.2 and 2.3 (message routing and response storage) are both covered by testing the complete message round-trip
- Properties 3.1 and 3.4 (gameId storage and general JSON field storage) can be combined into a single property about JSON field extraction
- Properties 4.1 and 4.2 (execution order and synchronization) are both validated by testing sequential execution
- Properties 6.1, 6.2, and 6.3 (state storage, accessibility, and message ordering) are all aspects of state management that can be tested together

### Correctness Properties

Property 1: YAML parsing preserves structure
*For any* valid YAML playtest file with turn definitions, parsing should produce a PlaytestDefinition with all client identifiers and message fields intact
**Validates: Requirements 1.1**

Property 2: Variable pattern recognition
*For any* string value in a message template, if it matches the pattern `<variableName>`, it should be identified as a variable reference requiring substitution
**Validates: Requirements 1.2**

Property 3: Invalid YAML produces errors
*For any* malformed YAML input, parsing should return an error (not panic or succeed with partial data)
**Validates: Requirements 1.3**

Property 4: Unique clients create unique connections
*For any* set of unique client identifiers in a playtest, the system should create exactly that many WebSocket connections
**Validates: Requirements 2.1**

Property 5: Client state isolation
*For any* two different clients, modifying one client's state should not affect the other client's state
**Validates: Requirements 2.4**

Property 6: JSON field extraction and storage
*For any* JSON field in a server response, if extracted and stored in the variable store, retrieving it should return the same value
**Validates: Requirements 3.1, 3.4**

Property 7: Variable substitution correctness
*For any* message template containing variable references, after substitution with stored values, all variable patterns should be replaced with their corresponding values
**Validates: Requirements 3.2**

Property 8: Missing variable detection
*For any* variable reference in a template, if that variable is not in the store, substitution should return an error
**Validates: Requirements 3.3**

Property 9: Variable persistence across turns
*For any* variable stored during an early turn, it should remain accessible in all subsequent turns within the same playtest execution
**Validates: Requirements 3.5**

Property 10: Sequential turn execution
*For any* sequence of turns in a playtest, they should execute in the exact order defined, with each turn completing before the next begins
**Validates: Requirements 4.1, 4.2**

Property 11: Turn logging completeness
*For any* executed turn, both the sent message and received response should appear in the execution log
**Validates: Requirements 4.4**

Property 12: Directory batch execution
*For any* directory containing N YAML files, executing the directory should run exactly N playtests
**Validates: Requirements 5.2**

Property 13: Exit code correctness
*For any* playtest execution, if all turns succeed, the exit code should be 0; if any turn fails, the exit code should be non-zero
**Validates: Requirements 5.3**

Property 14: Client state management
*For any* client receiving messages, all messages should be stored in chronological order and the most recent game_state should be accessible
**Validates: Requirements 6.1, 6.2, 6.3**

## Error Handling

The system handles errors at multiple levels:

1. **YAML Parsing Errors**: Invalid YAML syntax, missing required fields, or incorrect data types result in descriptive errors that halt execution before any network activity
2. **Connection Errors**: WebSocket connection failures are caught and reported with the server URL and error details
3. **Variable Substitution Errors**: References to undefined variables produce errors that include the variable name and available variables
4. **Message Send/Receive Errors**: Network errors during message exchange are caught and reported with context about which client and turn failed
5. **Server Response Errors**: Error messages from the server are captured and reported as test failures

All errors include sufficient context for debugging: client ID, turn number, message type, and relevant state.

## Testing Strategy

### Unit Tests

Unit tests will cover:
- YAML parsing with various valid and invalid inputs
- Variable pattern recognition and substitution logic
- Variable store operations (set, get, substitute)
- Client state management (message storage, state updates)
- Error message formatting

### Property-Based Tests

Property-based tests will use the `gopter` library for Go. Each test will run a minimum of 100 iterations with randomly generated inputs.

Property tests will cover:
- **Property 1**: Generate random valid YAML structures and verify parsing preserves all data
- **Property 2**: Generate random strings with and without variable patterns and verify recognition
- **Property 3**: Generate random malformed YAML and verify errors are returned
- **Property 4**: Generate random sets of client IDs and verify connection count matches
- **Property 5**: Generate random state modifications and verify isolation between clients
- **Property 6**: Generate random JSON structures and verify round-trip through variable store
- **Property 7**: Generate random templates with variables and verify complete substitution
- **Property 8**: Generate random variable references not in store and verify errors
- **Property 9**: Generate random multi-turn sequences and verify variable persistence
- **Property 10**: Generate random turn sequences and verify execution order
- **Property 11**: Generate random turns and verify logging completeness
- **Property 12**: Generate random directory structures and verify batch execution count
- **Property 13**: Generate random success/failure scenarios and verify exit codes
- **Property 14**: Generate random message sequences and verify state management

Each property-based test will be tagged with a comment referencing the design document property:
```go
// Feature: playtest-runner, Property 1: YAML parsing preserves structure
```

### Integration Tests

Integration tests will:
- Run complete playtest scenarios against a test server
- Verify end-to-end behavior with real WebSocket connections
- Test the example two-player-one-turn scenario
- Validate state capture and reporting

## Implementation Notes

### WebSocket Connection Management

- Connections are established lazily when a client first sends a message
- Connections remain open for the duration of the playtest
- All connections are closed when the playtest completes or fails
- Connection errors are immediately fatal to prevent cascading failures

### Variable Substitution Algorithm

1. Walk the message template recursively
2. For each string value, check if it matches the pattern `<[^>]+>`
3. If matched, extract the variable name and look it up in the store
4. Replace the string with the stored value
5. If not found, return an error
6. Empty strings are preserved as-is (not treated as variables)

### Automatic Variable Extraction

The system automatically extracts certain fields from server responses:
- `gameId` → stored as `globalGame`
- Additional fields can be configured in future versions

### Logging and Output

- Each turn logs: `[Client X] Sending: <message>`
- Each response logs: `[Client X] Received: <message type>`
- Errors log: `[Client X] Error at turn N: <details>`
- Final output includes: test name, pass/fail status, execution time

## Future Enhancements

- Support for assertions on server responses
- Configurable timeouts for message receipt
- Parallel execution of independent playtests
- Custom variable extraction rules in YAML
- State diff visualization for debugging
- Support for WebSocket close/reconnect scenarios
